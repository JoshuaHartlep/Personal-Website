import { readdir, writeFile } from 'fs/promises';
import { join, extname, basename } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import exifr from 'exifr';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = join(__dirname, '..');
const sportsDir = join(rootDir, 'src', 'assets', 'photography', 'sports');
const miscDir = join(rootDir, 'src', 'assets', 'photography', 'misc');
const outputFile = join(rootDir, 'src', 'utils', 'photo-dates.ts');

// Supported image extensions
const imageExtensions = ['.jpg', '.jpeg', '.png', '.webp', '.JPG', '.JPEG', '.PNG', '.WEBP'];

async function getImageFiles(dir) {
  try {
    const files = await readdir(dir);
    return files
      .filter(file => imageExtensions.includes(extname(file)))
      .map(file => join(dir, file));
  } catch (error) {
    console.warn(`Could not read directory ${dir}:`, error.message);
    return [];
  }
}

async function extractDateFromImage(imagePath) {
  try {
    const exifData = await exifr.parse(imagePath, {
      pick: ['DateTimeOriginal', 'CreateDate', 'ModifyDate'],
      reviveValues: true,
    });

    if (!exifData) {
      return null;
    }

    // Try DateTimeOriginal first (most accurate)
    if (exifData.DateTimeOriginal instanceof Date && !isNaN(exifData.DateTimeOriginal.getTime())) {
      return exifData.DateTimeOriginal.toISOString();
    }

    // Then CreateDate
    if (exifData.CreateDate instanceof Date && !isNaN(exifData.CreateDate.getTime())) {
      return exifData.CreateDate.toISOString();
    }

    // Finally ModifyDate
    if (exifData.ModifyDate instanceof Date && !isNaN(exifData.ModifyDate.getTime())) {
      return exifData.ModifyDate.toISOString();
    }

    return null;
  } catch (error) {
    console.warn(`Failed to read EXIF from ${imagePath}:`, error.message);
    return null;
  }
}

async function processPhotos() {
  console.log('Extracting photo dates from EXIF data...');
  
  const sportsFiles = await getImageFiles(sportsDir);
  const miscFiles = await getImageFiles(miscDir);
  const allFiles = [...sportsFiles, ...miscFiles];

  console.log(`Found ${allFiles.length} images to process`);

  const dateMap = {};
  let processed = 0;
  let withDates = 0;

  for (const filePath of allFiles) {
    const fileName = basename(filePath, extname(filePath));
    const date = await extractDateFromImage(filePath);
    
    if (date) {
      dateMap[fileName] = date;
      withDates++;
    }
    
    processed++;
    if (processed % 10 === 0) {
      console.log(`Processed ${processed}/${allFiles.length} images...`);
    }
  }

  console.log(`\nExtracted dates from ${withDates}/${allFiles.length} images`);

  // Generate TypeScript file
  const tsContent = `// Auto-generated file - do not edit manually
// This file is generated by scripts/extract-photo-dates.js
// Run: npm run extract-photo-dates

export const PHOTO_DATES: Record<string, string> = ${JSON.stringify(dateMap, null, 2)};
`;

  await writeFile(outputFile, tsContent, 'utf-8');
  console.log(`\nâœ… Generated ${outputFile}`);
  console.log(`   Found dates for ${withDates} photos`);
  console.log(`   Missing dates for ${allFiles.length - withDates} photos`);
}

processPhotos().catch(error => {
  console.error('Error processing photos:', error);
  process.exit(1);
});

